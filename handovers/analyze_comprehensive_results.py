#!/usr/bin/env python3
"""
Comprehensive analysis script for handover simulation data
Analyzes the various CSV files generated by the simulation
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import argparse
import warnings

warnings.filterwarnings('ignore')

class HandoverAnalyzer:
    def __init__(self, data_dir="."):
        self.data_dir = Path(data_dir)
        self.data = {}
        self.load_data()
    
    def load_data(self):
        """Load all CSV files generated by the simulation"""
        files = {
            'meas_reports': 'comprehensive_meas_reports.csv',
            'enb_rrc': 'comprehensive_enb_rrc_events.csv',
            'ue_rrc': 'comprehensive_ue_rrc_events.csv',
            'mobility': 'comprehensive_ue_mobility_trace.csv',
            'throughput': 'comprehensive_throughput_analysis.csv',
            'handover_stats': 'comprehensive_handover_statistics.csv',
            'rsrp': 'comprehensive_rsrp_measurements.csv',
            'base_stations': 'comprehensive_base_station_info.csv',
            'security_events': 'comprehensive_security_events.csv'
        }
        
        for key, filename in files.items():
            filepath = self.data_dir / filename
            if filepath.exists():
                try:
                    self.data[key] = pd.read_csv(filepath)
                    print(f"Loaded {filename}: {len(self.data[key])} records")
                except Exception as e:
                    print(f"Error loading {filename}: {e}")
            else:
                print(f"File not found: {filename}")
    
    def analyze_base_station_types(self):
        """Analyze base station distribution and characteristics"""
        if 'base_stations' not in self.data:
            print("Base station data not available")
            return
        
        bs_data = self.data['base_stations']
        print("\n" + "="*50)
        print("BASE STATION ANALYSIS")
        print("="*50)
        
        # Distribution by type
        type_counts = bs_data['cellType'].value_counts()
        print(f"\nBase Station Distribution:")
        for cell_type, count in type_counts.items():
            print(f"  {cell_type}: {count}")
        
        # Power distribution
        print(f"\nTransmit Power Distribution:")
        for cell_type in bs_data['cellType'].unique():
            power_data = bs_data[bs_data['cellType'] == cell_type]['txPowerDbm']
            print(f"  {cell_type}: {power_data.values[0] if len(power_data) > 0 else 'N/A'} dBm")
        
        # Plot base station positions
        plt.figure(figsize=(12, 8))
        colors = {'LEGITIMATE': 'green', 'FAULTY': 'orange', 'FAKE': 'red'}
        
        for cell_type in bs_data['cellType'].unique():
            type_data = bs_data[bs_data['cellType'] == cell_type]
            plt.scatter(type_data['posX'], type_data['posY'], 
                       c=colors.get(cell_type, 'blue'), 
                       label=f'{cell_type} ({len(type_data)})',
                       s=100, alpha=0.7)
            
            # Add cell IDs as labels
            for _, row in type_data.iterrows():
                plt.annotate(f"Cell {row['cellId']}", 
                           (row['posX'], row['posY']), 
                           xytext=(5, 5), textcoords='offset points',
                           fontsize=8)
        
        plt.xlabel('X Position (m)')
        plt.ylabel('Y Position (m)')
        plt.title('Base Station Deployment')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.savefig('base_station_deployment.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def analyze_mobility_patterns(self):
        """Analyze UE mobility patterns"""
        if 'mobility' not in self.data:
            print("Mobility data not available")
            return
        
        mobility = self.data['mobility']
        print("\n" + "="*50)
        print("MOBILITY ANALYSIS")
        print("="*50)
        
        # Speed statistics
        print(f"\nSpeed Statistics:")
        print(f"  Average Speed: {mobility['speed'].mean():.2f} m/s")
        print(f"  Max Speed: {mobility['speed'].max():.2f} m/s")
        print(f"  Min Speed: {mobility['speed'].min():.2f} m/s")
        
        # Plot mobility traces
        plt.figure(figsize=(15, 10))
        
        # Plot UE trajectories
        plt.subplot(2, 2, 1)
        for node_id in mobility['nodeId'].unique():
            ue_data = mobility[mobility['nodeId'] == node_id]
            plt.plot(ue_data['posX'], ue_data['posY'], 
                    label=f'UE {node_id}', alpha=0.7)
        
        # Add base station positions if available
        if 'base_stations' in self.data:
            bs_data = self.data['base_stations']
            colors = {'LEGITIMATE': 'green', 'FAULTY': 'orange', 'FAKE': 'red'}
            for cell_type in bs_data['cellType'].unique():
                type_data = bs_data[bs_data['cellType'] == cell_type]
                plt.scatter(type_data['posX'], type_data['posY'], 
                           c=colors.get(cell_type, 'blue'), 
                           marker='s', s=100, alpha=0.8)
        
        plt.xlabel('X Position (m)')
        plt.ylabel('Y Position (m)')
        plt.title('UE Mobility Traces')
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        plt.grid(True, alpha=0.3)
        
        # Speed over time
        plt.subplot(2, 2, 2)
        for node_id in mobility['nodeId'].unique():
            ue_data = mobility[mobility['nodeId'] == node_id]
            plt.plot(ue_data['time'], ue_data['speed'], 
                    label=f'UE {node_id}', alpha=0.7)
        plt.xlabel('Time (s)')
        plt.ylabel('Speed (m/s)')
        plt.title('UE Speed Over Time')
        plt.grid(True, alpha=0.3)
        
        # Speed distribution
        plt.subplot(2, 2, 3)
        plt.hist(mobility['speed'], bins=30, alpha=0.7, edgecolor='black')
        plt.xlabel('Speed (m/s)')
        plt.ylabel('Frequency')
        plt.title('Speed Distribution')
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('mobility_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def analyze_handover_performance(self):
        """Analyze handover events and performance"""
        if 'handover_stats' not in self.data:
            print("Handover statistics data not available")
            return
        
        ho_stats = self.data['handover_stats']
        print("\n" + "="*50)
        print("HANDOVER PERFORMANCE ANALYSIS")
        print("="*50)
        
        # Count handover events by type
        ho_starts = ho_stats[ho_stats['event'] == 'HO_START']
        ho_ends = ho_stats[ho_stats['event'] == 'HO_END_OK']
        
        print(f"\nHandover Events:")
        print(f"  Total Handover Attempts: {len(ho_starts)}")
        print(f"  Successful Handovers: {len(ho_ends)}")
        if len(ho_starts) > 0:
            success_rate = len(ho_ends) / len(ho_starts) * 100
            print(f"  Success Rate: {success_rate:.2f}%")
        
        # Analyze handovers by base station type
        if len(ho_starts) > 0:
            print(f"\nHandovers by Source Cell Type:")
            source_counts = ho_starts['sourceCellType'].value_counts()
            for cell_type, count in source_counts.items():
                print(f"  From {cell_type}: {count}")
            
            print(f"\nHandovers by Target Cell Type:")
            target_counts = ho_starts['targetCellType'].value_counts()
            for cell_type, count in target_counts.items():
                print(f"  To {cell_type}: {count}")
        
        # Plot handover timing
        if len(ho_starts) > 0:
            plt.figure(figsize=(12, 8))
            
            plt.subplot(2, 2, 1)
            plt.plot(ho_starts['time'], range(len(ho_starts)), 'b-', alpha=0.7, label='Handover Attempts')
            plt.plot(ho_ends['time'], range(len(ho_ends)), 'g-', alpha=0.7, label='Successful Handovers')
            plt.xlabel('Time (s)')
            plt.ylabel('Cumulative Count')
            plt.title('Handover Events Over Time')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            # Handover distribution by cell type
            plt.subplot(2, 2, 2)
            source_counts.plot(kind='bar', alpha=0.7)
            plt.title('Handovers by Source Cell Type')
            plt.ylabel('Count')
            plt.xticks(rotation=45)
            
            plt.subplot(2, 2, 3)
            target_counts.plot(kind='bar', alpha=0.7, color='orange')
            plt.title('Handovers by Target Cell Type')
            plt.ylabel('Count')
            plt.xticks(rotation=45)
            
            plt.tight_layout()
            plt.savefig('handover_analysis.png', dpi=300, bbox_inches='tight')
            plt.show()
    
    def analyze_signal_quality(self):
        """Analyze RSRP and RSRQ measurements"""
        if 'rsrp' not in self.data:
            print("RSRP data not available")
            return
        
        rsrp_data = self.data['rsrp']
        print("\n" + "="*50)
        print("SIGNAL QUALITY ANALYSIS")
        print("="*50)
        
        # Overall statistics
        print(f"\nOverall Signal Quality:")
        print(f"  Average RSRP: {rsrp_data['rsrpDbm'].mean():.2f} dBm")
        print(f"  Average RSRQ: {rsrp_data['rsrqDb'].mean():.2f} dB")
        
        # Statistics by cell type
        print(f"\nSignal Quality by Cell Type:")
        for cell_type in rsrp_data['cellType'].unique():
            type_data = rsrp_data[rsrp_data['cellType'] == cell_type]
            print(f"  {cell_type}:")
            print(f"    Average RSRP: {type_data['rsrpDbm'].mean():.2f} dBm")
            print(f"    Average RSRQ: {type_data['rsrqDb'].mean():.2f} dB")
            print(f"    Measurements: {len(type_data)}")
        
        # Plot signal quality
        plt.figure(figsize=(15, 10))
        
        # RSRP over time by cell type
        plt.subplot(2, 3, 1)
        for cell_type in rsrp_data['cellType'].unique():
            type_data = rsrp_data[rsrp_data['cellType'] == cell_type]
            plt.scatter(type_data['time'], type_data['rsrpDbm'], 
                       label=cell_type, alpha=0.6, s=20)
        plt.xlabel('Time (s)')
        plt.ylabel('RSRP (dBm)')
        plt.title('RSRP Over Time by Cell Type')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # RSRQ over time by cell type
        plt.subplot(2, 3, 2)
        for cell_type in rsrp_data['cellType'].unique():
            type_data = rsrp_data[rsrp_data['cellType'] == cell_type]
            plt.scatter(type_data['time'], type_data['rsrqDb'], 
                       label=cell_type, alpha=0.6, s=20)
        plt.xlabel('Time (s)')
        plt.ylabel('RSRQ (dB)')
        plt.title('RSRQ Over Time by Cell Type')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # RSRP distribution by cell type
        plt.subplot(2, 3, 3)
        rsrp_data.boxplot(column='rsrpDbm', by='cellType', ax=plt.gca())
        plt.title('RSRP Distribution by Cell Type')
        plt.suptitle('')  # Remove default title
        plt.xticks(rotation=45)
        
        # RSRQ distribution by cell type
        plt.subplot(2, 3, 4)
        rsrp_data.boxplot(column='rsrqDb', by='cellType', ax=plt.gca())
        plt.title('RSRQ Distribution by Cell Type')
        plt.suptitle('')  # Remove default title
        plt.xticks(rotation=45)
        
        # Signal quality correlation
        plt.subplot(2, 3, 5)
        colors = {'LEGITIMATE': 'green', 'FAULTY': 'orange', 'FAKE': 'red'}
        for cell_type in rsrp_data['cellType'].unique():
            type_data = rsrp_data[rsrp_data['cellType'] == cell_type]
            plt.scatter(type_data['rsrpDbm'], type_data['rsrqDb'], 
                       c=colors.get(cell_type, 'blue'), 
                       label=cell_type, alpha=0.6)
        plt.xlabel('RSRP (dBm)')
        plt.ylabel('RSRQ (dB)')
        plt.title('RSRP vs RSRQ')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('signal_quality_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def analyze_security_events(self):
        """Analyze security-related events"""
        if 'security_events' not in self.data:
            print("Security events data not available")
            return
        
        security = self.data['security_events']
        if len(security) == 0:
            print("No security events recorded")
            return
        
        print("\n" + "="*50)
        print("SECURITY ANALYSIS")
        print("="*50)
        
        # Count events by type
        event_counts = security['eventType'].value_counts()
        print(f"\nSecurity Events:")
        for event_type, count in event_counts.items():
            print(f"  {event_type}: {count}")
        
        # Plot security events over time
        plt.figure(figsize=(12, 6))
        
        plt.subplot(1, 2, 1)
        colors = plt.cm.Set3(np.linspace(0, 1, len(event_counts)))
        for i, event_type in enumerate(event_counts.index):
            event_data = security[security['eventType'] == event_type]
            plt.scatter(event_data['time'], [i] * len(event_data), 
                       c=[colors[i]], label=event_type, s=50, alpha=0.7)
        
        plt.xlabel('Time (s)')
        plt.ylabel('Event Type')
        plt.title('Security Events Timeline')
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        plt.grid(True, alpha=0.3)
        
        plt.subplot(1, 2, 2)
        event_counts.plot(kind='bar', alpha=0.7)
        plt.title('Security Event Distribution')
        plt.ylabel('Count')
        plt.xticks(rotation=45)
        
        plt.tight_layout()
        plt.savefig('security_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def analyze_throughput(self):
        """Analyze throughput and QoS metrics"""
        if 'throughput' not in self.data:
            print("Throughput data not available")
            return
        
        throughput = self.data['throughput']
        if len(throughput) == 0:
            print("No throughput data available")
            return
        
        print("\n" + "="*50)
        print("THROUGHPUT AND QOS ANALYSIS")
        print("="*50)
        
        # Overall statistics
        print(f"\nOverall Performance:")
        print(f"  Average Throughput: {throughput['throughputMbps'].mean():.2f} Mbps")
        print(f"  Average Delay: {throughput['delayMs'].mean():.2f} ms")
        print(f"  Average Jitter: {throughput['jitterMs'].mean():.2f} ms")
        print(f"  Average Packet Loss: {throughput['packetLossPercent'].mean():.2f}%")
        
        # Plot throughput metrics
        plt.figure(figsize=(15, 10))
        
        # Throughput over time
        plt.subplot(2, 3, 1)
        for flow_id in throughput['flowId'].unique()[:10]:  # Limit to first 10 flows
            flow_data = throughput[throughput['flowId'] == flow_id]
            plt.plot(flow_data['time'], flow_data['throughputMbps'], 
                    alpha=0.7, label=f'Flow {flow_id}')
        plt.xlabel('Time (s)')
        plt.ylabel('Throughput (Mbps)')
        plt.title('Throughput Over Time')
        plt.grid(True, alpha=0.3)
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        
        # Delay over time
        plt.subplot(2, 3, 2)
        plt.plot(throughput['time'], throughput['delayMs'], alpha=0.7)
        plt.xlabel('Time (s)')
        plt.ylabel('Delay (ms)')
        plt.title('Delay Over Time')
        plt.grid(True, alpha=0.3)
        
        # Packet loss over time
        plt.subplot(2, 3, 3)
        plt.plot(throughput['time'], throughput['packetLossPercent'], alpha=0.7, color='red')
        plt.xlabel('Time (s)')
        plt.ylabel('Packet Loss (%)')
        plt.title('Packet Loss Over Time')
        plt.grid(True, alpha=0.3)
        
        # Distributions
        plt.subplot(2, 3, 4)
        plt.hist(throughput['throughputMbps'], bins=30, alpha=0.7, edgecolor='black')
        plt.xlabel('Throughput (Mbps)')
        plt.ylabel('Frequency')
        plt.title('Throughput Distribution')
        plt.grid(True, alpha=0.3)
        
        plt.subplot(2, 3, 5)
        plt.hist(throughput['delayMs'], bins=30, alpha=0.7, edgecolor='black', color='orange')
        plt.xlabel('Delay (ms)')
        plt.ylabel('Frequency')
        plt.title('Delay Distribution')
        plt.grid(True, alpha=0.3)
        
        plt.subplot(2, 3, 6)
        plt.hist(throughput['packetLossPercent'], bins=30, alpha=0.7, edgecolor='black', color='red')
        plt.xlabel('Packet Loss (%)')
        plt.ylabel('Frequency')
        plt.title('Packet Loss Distribution')
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('throughput_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def generate_summary_report(self):
        """Generate a comprehensive summary report"""
        print("\n" + "="*70)
        print("COMPREHENSIVE HANDOVER SIMULATION SUMMARY REPORT")
        print("="*70)
        
        # File availability
        print(f"\nData Files Available:")
        for key, data in self.data.items():
            print(f"  {key}: {len(data) if data is not None else 0} records")
        
        # Run all analyses
        self.analyze_base_station_types()
        self.analyze_mobility_patterns()
        self.analyze_handover_performance()
        self.analyze_signal_quality()
        self.analyze_security_events()
        self.analyze_throughput()
        
        print(f"\n" + "="*70)
        print("ANALYSIS COMPLETE - Check generated PNG files for visualizations")
        print("="*70)

def main():
    parser = argparse.ArgumentParser(description='Analyze handover simulation data')
    parser.add_argument('--data-dir', default='.', 
                       help='Directory containing CSV files (default: current directory)')
    parser.add_argument('--analysis', choices=['all', 'base_stations', 'mobility', 'handover', 
                                              'signal', 'security', 'throughput'], 
                       default='all', help='Type of analysis to perform')
    
    args = parser.parse_args()
    
    analyzer = HandoverAnalyzer(args.data_dir)
    
    if args.analysis == 'all':
        analyzer.generate_summary_report()
    elif args.analysis == 'base_stations':
        analyzer.analyze_base_station_types()
    elif args.analysis == 'mobility':
        analyzer.analyze_mobility_patterns()
    elif args.analysis == 'handover':
        analyzer.analyze_handover_performance()
    elif args.analysis == 'signal':
        analyzer.analyze_signal_quality()
    elif args.analysis == 'security':
        analyzer.analyze_security_events()
    elif args.analysis == 'throughput':
        analyzer.analyze_throughput()

if __name__ == "__main__":
    main()
